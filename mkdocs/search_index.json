{
    "docs": [
        {
            "location": "/",
            "text": "zend-hydrator\n\n\n\n\n\n\nZend\\Hydrator\n provides utilities for mapping arrays to objects, and vice\nversa, including facilities for filtering which data is mapped as well as\nproviding mechanisms for mapping nested structures.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-hydrator/issues\n\n\nDocumentation is at http://framework.zend.com/manual/current/en/index.html#zend-stdlib",
            "title": "Home"
        },
        {
            "location": "/#zend-hydrator",
            "text": "Zend\\Hydrator  provides utilities for mapping arrays to objects, and vice\nversa, including facilities for filtering which data is mapped as well as\nproviding mechanisms for mapping nested structures.   File issues at https://github.com/zendframework/zend-hydrator/issues  Documentation is at http://framework.zend.com/manual/current/en/index.html#zend-stdlib",
            "title": "zend-hydrator"
        },
        {
            "location": "/quick-start/",
            "text": "zend-hydrator\n\n\nHydration is the act of populating an object from a set of data.\n\n\nzend-hydrator is a simple component to provide mechanisms both for hydrating\nobjects, as well as extracting data sets from them.\n\n\nThe component consists of interfaces, and several implementations for common use cases.\n\n\nBase Interfaces\n\n\nExtractionInterface\n\n\nnamespace Zend\\Hydrator;\n\ninterface ExtractionInterface\n{\n    /\n     * Extract values from an object\n     *\n     * @param  object $object\n     * @return array\n     */\n    public function extract($object);\n}\n\n\n\n\nHydrationInterface\n\n\nnamespace Zend\\Hydrator;\n\ninterface HydrationInterface\n{\n    /\n     * Hydrate $object with the provided $data.\n     *\n     * @param  array $data\n     * @param  object $object\n     * @return object\n     */\n    public function hydrate(array $data, $object);\n}\n\n\n\n\nHydratorInterface\n\n\nnamespace Zend\\Hydrator;\n\ninterface HydratorInterface extends\n    ExtractionInterface,\n    HydrationInterface\n{\n}\n\n\n\n\nUsage\n\n\nUsage involves instantiating the hydrator, and then passing information to it.\n\n\nuse Zend\\Hydrator;\n$hydrator = new Hydrator\\ArraySerializable();\n\n$object = new ArrayObject(array());\n\n$hydrator->hydrate($someData, $object);\n\n// or, if the object has data we want as an array:\n$data = $hydrator->extract($object);\n\n\n\n\nAvailable Implementations\n\n\nZend\\Hydrator\\ArraySerializable\n\n\nFollows the definition of \nArrayObject\n. Objects must implement either the \nexchangeArray()\n or\n\npopulate()\n methods to support hydration, and the \ngetArrayCopy()\n method to support extraction.\n\n\nZend\\Hydrator\\ClassMethods\n\n\nAny data key matching a setter method will be called in order to hydrate; any method matching a\ngetter method will be called for extraction.\n\n\nZend\\Hydrator\\DelegatingHydrator\n\n\nComposes a hydrator locator, and will delegate \nhydrate()\n and \nextract()\n calls\nto the appropriate one based upon the class name of the object being operated\non.\n\n\n// Instantiate each hydrator you wish to delegate to\n$albumHydrator = new Zend\\Hydrator\\ClassMethods;\n$artistHydrator = new Zend\\Hydrator\\ClassMethods;\n\n// Map the entity class name to the hydrator using the HydratorPluginManager.\n// In this case we have two entity classes, \"Album\" and \"Artist\".\n$hydrators = new Zend\\Hydrator\\HydratorPluginManager;\n$hydrators->setService('Album', $albumHydrator);\n$hydrators->setService('Artist', $artistHydrator);\n\n// Create the DelegatingHydrator and tell it to use our configured hydrator locator\n$delegating = new Zend\\Hydrator\\DelegatingHydrator($hydrators);\n\n// Now we can use $delegating to hydrate or extract any supported object    \n$array = $delegating->extract(new Artist);\n$artist = $delegating->hydrate($data, new Artist);\n\n\n\n\nZend\\Hydrator\\ObjectProperty\n\n\nAny data key matching a publicly accessible property will be hydrated; any public properties\nwill be used for extraction.\n\n\nZend\\Hydrator\\Reflection\n\n\nSimilar to the \nObjectProperty\n hydrator, but uses \nPHP's reflection API\n\nto hydrate or extract properties of any visibility. Any data key matching an\nexisting property will be hydrated; any existing properties will be used for\nextraction.",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#zend-hydrator",
            "text": "Hydration is the act of populating an object from a set of data.  zend-hydrator is a simple component to provide mechanisms both for hydrating\nobjects, as well as extracting data sets from them.  The component consists of interfaces, and several implementations for common use cases.",
            "title": "zend-hydrator"
        },
        {
            "location": "/quick-start/#base-interfaces",
            "text": "",
            "title": "Base Interfaces"
        },
        {
            "location": "/quick-start/#extractioninterface",
            "text": "namespace Zend\\Hydrator;\n\ninterface ExtractionInterface\n{\n    /\n     * Extract values from an object\n     *\n     * @param  object $object\n     * @return array\n     */\n    public function extract($object);\n}",
            "title": "ExtractionInterface"
        },
        {
            "location": "/quick-start/#hydrationinterface",
            "text": "namespace Zend\\Hydrator;\n\ninterface HydrationInterface\n{\n    /\n     * Hydrate $object with the provided $data.\n     *\n     * @param  array $data\n     * @param  object $object\n     * @return object\n     */\n    public function hydrate(array $data, $object);\n}",
            "title": "HydrationInterface"
        },
        {
            "location": "/quick-start/#hydratorinterface",
            "text": "namespace Zend\\Hydrator;\n\ninterface HydratorInterface extends\n    ExtractionInterface,\n    HydrationInterface\n{\n}",
            "title": "HydratorInterface"
        },
        {
            "location": "/quick-start/#usage",
            "text": "Usage involves instantiating the hydrator, and then passing information to it.  use Zend\\Hydrator;\n$hydrator = new Hydrator\\ArraySerializable();\n\n$object = new ArrayObject(array());\n\n$hydrator->hydrate($someData, $object);\n\n// or, if the object has data we want as an array:\n$data = $hydrator->extract($object);",
            "title": "Usage"
        },
        {
            "location": "/quick-start/#available-implementations",
            "text": "",
            "title": "Available Implementations"
        },
        {
            "location": "/quick-start/#zend92hydrator92arrayserializable",
            "text": "Follows the definition of  ArrayObject . Objects must implement either the  exchangeArray()  or populate()  methods to support hydration, and the  getArrayCopy()  method to support extraction.",
            "title": "Zend\\Hydrator\\ArraySerializable"
        },
        {
            "location": "/quick-start/#zend92hydrator92classmethods",
            "text": "Any data key matching a setter method will be called in order to hydrate; any method matching a\ngetter method will be called for extraction.",
            "title": "Zend\\Hydrator\\ClassMethods"
        },
        {
            "location": "/quick-start/#zend92hydrator92delegatinghydrator",
            "text": "Composes a hydrator locator, and will delegate  hydrate()  and  extract()  calls\nto the appropriate one based upon the class name of the object being operated\non.  // Instantiate each hydrator you wish to delegate to\n$albumHydrator = new Zend\\Hydrator\\ClassMethods;\n$artistHydrator = new Zend\\Hydrator\\ClassMethods;\n\n// Map the entity class name to the hydrator using the HydratorPluginManager.\n// In this case we have two entity classes, \"Album\" and \"Artist\".\n$hydrators = new Zend\\Hydrator\\HydratorPluginManager;\n$hydrators->setService('Album', $albumHydrator);\n$hydrators->setService('Artist', $artistHydrator);\n\n// Create the DelegatingHydrator and tell it to use our configured hydrator locator\n$delegating = new Zend\\Hydrator\\DelegatingHydrator($hydrators);\n\n// Now we can use $delegating to hydrate or extract any supported object    \n$array = $delegating->extract(new Artist);\n$artist = $delegating->hydrate($data, new Artist);",
            "title": "Zend\\Hydrator\\DelegatingHydrator"
        },
        {
            "location": "/quick-start/#zend92hydrator92objectproperty",
            "text": "Any data key matching a publicly accessible property will be hydrated; any public properties\nwill be used for extraction.",
            "title": "Zend\\Hydrator\\ObjectProperty"
        },
        {
            "location": "/quick-start/#zend92hydrator92reflection",
            "text": "Similar to the  ObjectProperty  hydrator, but uses  PHP's reflection API \nto hydrate or extract properties of any visibility. Any data key matching an\nexisting property will be hydrated; any existing properties will be used for\nextraction.",
            "title": "Zend\\Hydrator\\Reflection"
        },
        {
            "location": "/filter/",
            "text": "Zend\\Hydrator\\Filter\n\n\nHydrator filters allow you to manipulate the behavior of the \nextract()\n\noperation.  This is especially useful, if you want to omit some internals (e.g.\n\ngetServiceManager()\n) from the array representation.\n\n\nIt comes with a helpful \nComposite\n implementation, and several filters for\ncommon use cases. The filters are composed in the \nAbstractHydrator\n, so you can\nstart using them immediately in any custom extensions you write that extend that\nclass.\n\n\nnamespace Zend\\Hydrator\\Filter;\n\ninterface FilterInterface\n{\n    /**\n     * Should return true, if the given filter\n     * does not match\n     *\n     * @param string $property The name of the property\n     * @return bool\n     */\n    public function filter($property);\n}\n\n\n\n\nIf it returns true, the key/value pairs will be in the extracted arrays - if it\nreturns false, you'll not see them again.\n\n\nFilter implementations\n\n\nZend\\Hydrator\\Filter\\GetFilter\n\n\nThis filter is used in the \nClassMethods\n hydrator to decide which getters will\nbe extracted. It checks if the key to extract starts with \nget\n or the object\ncontains a method beginning with \nget\n (e.g., \nZend\\Foo\\Bar::getFoo\n).\n\n\nZend\\Hydrator\\Filter\\HasFilter\n\n\nThis filter is used in the \nClassMethods\n hydrator to decide which \nhas\n methods\nwill be extracted. It checks if the key to extract begins with \nhas\n or the\nobject contains a method beginning with \nhas\n (e.g., \nZend\\Foo\\Bar::hasFoo\n).\n\n\nZend\\Hydrator\\Filter\\IsFilter\n\n\nThis filter is used in the \nClassMethods\n hydrator to decide which \nis\n methods\nwill be extracted. It checks if the key to extract begins with \nis\n or the\nobject contains a method beginning with \nis\n (e.g., \nZend\\Foo\\Bar::isFoo\n).\n\n\nZend\\Hydrator\\Filter\\MethodMatchFilter\n\n\nThis filter allows you to omit methods during extraction that match the\ncondition defined in the composite.  The name of the method is specified in the\nconstructor of this filter; the second parameter decides whether to use white or\nblacklisting to decide (whitelisting retains only the matching method, blacklist\nomits any matching method). The default is blacklisting - pass \nfalse\n to change\nthe behavior.\n\n\nZend\\Hydrator\\Filter\\NumberOfParameterFilter\n\n\nThis filter is used in the \nClassMethods\n hydrator to check the number of\nparameters. By convention, the \nget\n, \nhas\n and \nis\n methods do not get any\nparameters - but it may happen. You can add your own number of required\nparameters, simply add the number to the constructor. The default value is 0. If\nthe method has more or fewer parameters than what the filter accepts, it will be\nomitted.\n\n\nRemove filters\n\n\nIf you want to tell e.g. the \nClassMethods\n hydrator, to not extract methods that start with \nis\n,\nremove the related filter:\n\n\n$hydrator = new ClassMethods(false);\n$hydrator->removeFilter('is');\n\n\n\n\nAfter performing the above, the key/value pairs for \nis\n methods will not end up\nin your extracted array anymore. The filters can be used in any hydrator, but\nthe \nClassMethods\n hydrator is the only one, that has pre-registered filters:\n\n\n$this->filterComposite->addFilter('is', new IsFilter());\n$this->filterComposite->addFilter('has', new HasFilter());\n$this->filterComposite->addFilter('get', new GetFilter());\n$this->filterComposite->addFilter(\n    'parameter',\n    new NumberOfParameterFilter(),\n    FilterComposite::CONDITION_AND\n);\n\n\n\n\nIf these are not appropriate for your object, you can unregister them as shown\nin the previous example.\n\n\nAdd filters\n\n\nYou can add filters to any hydrator that extends the \nAbstractHydrator\n. Filters\ncan either implement \nFilterInterface\n, or simply be PHP callables:\n\n\n$hydrator->addFilter('len', function($property) {\n    if (strlen($property) !== 3) {\n        return false;\n    }\n    return true;\n});\n\n\n\n\nBy default, every filter you add will be added with a conditional \nor\n. If you\nwant to add it with \nand\n (as the \nNumberOfParameterFilter\n that is added to the\n\nClassMethods\n hydrator by default), provide the conditon as the third argument\nto \naddFilter\n:\n\n\n$hydrator->addFilter('len', function($property) {\n    if (strlen($property) !== 3) {\n        return false;\n    }\n    return true;\n}, FilterComposite::CONDITION_AND);\n\n\n\n\nOne common use case for filters is to omit getters for values that you do not\nwant to represent, such as a service manager instance:\n\n\n$hydrator->addFilter(\n  'servicemanager',\n  new MethodMatchFilter('getServiceManager'),\n  FilterComposite::CONDITION_AND\n);\n\n\n\n\nThe example above will exclude the \ngetServiceManager()\n method and the\n\nservicemanager\n key from extraction, even if the \nget\n filter wants to add it.\n\n\nUse FilterComposite for complex filters\n\n\nFilterComposite\n implements \nFilterInterface\n as well, so you can add it as\na regular filter to the hydrator. One benefit of this implementation is that you\ncan add the filters with a condition and accomplish complex requirements using\ndifferent composites with different conditions. You can pass the following\nconditions to the 3rd parameter, when you add a filter:\n\n\nZend\\Hydrator\\Filter\\FilterComposite::CONDITION_OR\n\n\nAt the given level of the composite, at least one filter in that condition block\nhas to return true to extract the value.\n\n\nZend\\Hydrator\\Filter\\FilterComposite::CONDITION_AND\n\n\nAt the given level of the composite, all filters in that condition block must\nreturn true to extract the value.\n\n\nFilterComposite Examples\n\n\nThis composition will have a similar logic as the if below:\n\n\n$composite = new FilterComposite();\n\n$composite->addFilter('one', $condition1);\n$composite->addFilter('two', $condition2);\n$composite->addFilter('three', $condition3);\n$composite->addFilter('four', $condition4, FilterComposite::CONDITION_AND);\n$composite->addFilter('five', $condition5, FilterComposite::CONDITION_AND);\n\n// This is what's happening internally\nif (\n     ($condition1\n        || $condition2\n        || $condition3\n     ) && ($condition4\n        && $condition5\n     )\n) {\n    //do extraction\n}\n\n\n\n\nIf you only have one condition (e.g., only an \nand\n or \nor\n) block, the other\none will be completely ignored.\n\n\nA bit more complex filter can look like this:\n\n\n$composite = new FilterComposite();\n$composite->addFilter(\n    'servicemanager',\n    new MethodMatchFilter('getServiceManager'),\n    FilterComposite::CONDITION_AND\n);\n$composite->addFilter(\n    'eventmanager',\n    new MethodMatchFilter('getEventManager'),\n    FilterComposite::CONDITION_AND\n);\n\n$hydrator->addFilter('excludes', $composite, FilterComposite::CONDITION_AND);\n\n// Internal\nif (( // default composite inside the hydrator\n        ($getFilter\n            || $hasFilter\n            || $isFilter\n        ) && (\n            $numberOfParameterFilter\n        )\n   ) && ( // new composite, added to the one above\n        $serviceManagerFilter\n        && $eventManagerFilter\n   )\n) {\n    // do extraction\n}\n\n\n\n\nIf you perform this on the \nClassMethods\n hydrator, all getters will get\nextracted, except for \ngetServiceManager()\n and \ngetEventManager()\n.\n\n\nUsing the provider interface\n\n\nFilterProviderInterface\n allows you to configure the behavior of the hydrator\ninside your objects.\n\n\nnamespace Zend\\Hydrator\\Filter;\n\ninterface FilterProviderInterface\n{\n    /**\n     * Provides a filter for hydration\n     *\n     * @return FilterInterface\n     */\n    public function getFilter();\n}\n\n\n\n\n(The \ngetFilter()\n method is automatically excluded from \nextract()\n.) If the\nextracted object implements the \nZend\\Hydrator\\Filter\\FilterProviderInterface\n,\nthe returned \nFilterInterface\n instance can also be a \nFilterComposite\n.\n\n\nFor example:\n\n\nClass Foo implements FilterProviderInterface\n{\n     public function getFoo()\n     {\n         return 'foo';\n     }\n\n     public function hasFoo()\n     {\n         return true;\n     }\n\n     public function getServiceManager()\n     {\n         return 'servicemanager';\n     }\n\n     public function getEventManager()\n     {\n         return 'eventmanager';\n     }\n\n     public function getFilter()\n     {\n         $composite = new FilterComposite();\n         $composite->addFilter('get', new GetFilter());\n\n         $exclusionComposite = new FilterComposite();\n         $exclusionComposite->addFilter(\n             'servicemanager',\n             new MethodMatchFilter('getServiceManager'),\n             FilterComposite::CONDITION_AND\n             );\n         $exclusionComposite->addFilter(\n             'eventmanager',\n             new MethodMatchFilter('getEventManager'),\n             FilterComposite::CONDITION_AND\n         );\n\n         $composite->addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND);\n\n         return $composite;\n     }\n}\n\n$hydrator = new ClassMethods(false);\n$extractedArray = $hydrator->extract(new Foo());\n\n\n\n\n$extractedArray\n will only have 'foo' => 'foo'; all other values are\nexcluded from extraction.\n\n\n\n\nNote\n\n\nAll pre-registered filters from the \nClassMethods\n hydrator are ignored when\nthis interface is used.",
            "title": "Filters"
        },
        {
            "location": "/filter/#zend92hydrator92filter",
            "text": "Hydrator filters allow you to manipulate the behavior of the  extract() \noperation.  This is especially useful, if you want to omit some internals (e.g. getServiceManager() ) from the array representation.  It comes with a helpful  Composite  implementation, and several filters for\ncommon use cases. The filters are composed in the  AbstractHydrator , so you can\nstart using them immediately in any custom extensions you write that extend that\nclass.  namespace Zend\\Hydrator\\Filter;\n\ninterface FilterInterface\n{\n    /**\n     * Should return true, if the given filter\n     * does not match\n     *\n     * @param string $property The name of the property\n     * @return bool\n     */\n    public function filter($property);\n}  If it returns true, the key/value pairs will be in the extracted arrays - if it\nreturns false, you'll not see them again.",
            "title": "Zend\\Hydrator\\Filter"
        },
        {
            "location": "/filter/#filter-implementations",
            "text": "",
            "title": "Filter implementations"
        },
        {
            "location": "/filter/#zend92hydrator92filter92getfilter",
            "text": "This filter is used in the  ClassMethods  hydrator to decide which getters will\nbe extracted. It checks if the key to extract starts with  get  or the object\ncontains a method beginning with  get  (e.g.,  Zend\\Foo\\Bar::getFoo ).",
            "title": "Zend\\Hydrator\\Filter\\GetFilter"
        },
        {
            "location": "/filter/#zend92hydrator92filter92hasfilter",
            "text": "This filter is used in the  ClassMethods  hydrator to decide which  has  methods\nwill be extracted. It checks if the key to extract begins with  has  or the\nobject contains a method beginning with  has  (e.g.,  Zend\\Foo\\Bar::hasFoo ).",
            "title": "Zend\\Hydrator\\Filter\\HasFilter"
        },
        {
            "location": "/filter/#zend92hydrator92filter92isfilter",
            "text": "This filter is used in the  ClassMethods  hydrator to decide which  is  methods\nwill be extracted. It checks if the key to extract begins with  is  or the\nobject contains a method beginning with  is  (e.g.,  Zend\\Foo\\Bar::isFoo ).",
            "title": "Zend\\Hydrator\\Filter\\IsFilter"
        },
        {
            "location": "/filter/#zend92hydrator92filter92methodmatchfilter",
            "text": "This filter allows you to omit methods during extraction that match the\ncondition defined in the composite.  The name of the method is specified in the\nconstructor of this filter; the second parameter decides whether to use white or\nblacklisting to decide (whitelisting retains only the matching method, blacklist\nomits any matching method). The default is blacklisting - pass  false  to change\nthe behavior.",
            "title": "Zend\\Hydrator\\Filter\\MethodMatchFilter"
        },
        {
            "location": "/filter/#zend92hydrator92filter92numberofparameterfilter",
            "text": "This filter is used in the  ClassMethods  hydrator to check the number of\nparameters. By convention, the  get ,  has  and  is  methods do not get any\nparameters - but it may happen. You can add your own number of required\nparameters, simply add the number to the constructor. The default value is 0. If\nthe method has more or fewer parameters than what the filter accepts, it will be\nomitted.",
            "title": "Zend\\Hydrator\\Filter\\NumberOfParameterFilter"
        },
        {
            "location": "/filter/#remove-filters",
            "text": "If you want to tell e.g. the  ClassMethods  hydrator, to not extract methods that start with  is ,\nremove the related filter:  $hydrator = new ClassMethods(false);\n$hydrator->removeFilter('is');  After performing the above, the key/value pairs for  is  methods will not end up\nin your extracted array anymore. The filters can be used in any hydrator, but\nthe  ClassMethods  hydrator is the only one, that has pre-registered filters:  $this->filterComposite->addFilter('is', new IsFilter());\n$this->filterComposite->addFilter('has', new HasFilter());\n$this->filterComposite->addFilter('get', new GetFilter());\n$this->filterComposite->addFilter(\n    'parameter',\n    new NumberOfParameterFilter(),\n    FilterComposite::CONDITION_AND\n);  If these are not appropriate for your object, you can unregister them as shown\nin the previous example.",
            "title": "Remove filters"
        },
        {
            "location": "/filter/#add-filters",
            "text": "You can add filters to any hydrator that extends the  AbstractHydrator . Filters\ncan either implement  FilterInterface , or simply be PHP callables:  $hydrator->addFilter('len', function($property) {\n    if (strlen($property) !== 3) {\n        return false;\n    }\n    return true;\n});  By default, every filter you add will be added with a conditional  or . If you\nwant to add it with  and  (as the  NumberOfParameterFilter  that is added to the ClassMethods  hydrator by default), provide the conditon as the third argument\nto  addFilter :  $hydrator->addFilter('len', function($property) {\n    if (strlen($property) !== 3) {\n        return false;\n    }\n    return true;\n}, FilterComposite::CONDITION_AND);  One common use case for filters is to omit getters for values that you do not\nwant to represent, such as a service manager instance:  $hydrator->addFilter(\n  'servicemanager',\n  new MethodMatchFilter('getServiceManager'),\n  FilterComposite::CONDITION_AND\n);  The example above will exclude the  getServiceManager()  method and the servicemanager  key from extraction, even if the  get  filter wants to add it.",
            "title": "Add filters"
        },
        {
            "location": "/filter/#use-filtercomposite-for-complex-filters",
            "text": "FilterComposite  implements  FilterInterface  as well, so you can add it as\na regular filter to the hydrator. One benefit of this implementation is that you\ncan add the filters with a condition and accomplish complex requirements using\ndifferent composites with different conditions. You can pass the following\nconditions to the 3rd parameter, when you add a filter:",
            "title": "Use FilterComposite for complex filters"
        },
        {
            "location": "/filter/#zend92hydrator92filter92filtercompositecondition95or",
            "text": "At the given level of the composite, at least one filter in that condition block\nhas to return true to extract the value.",
            "title": "Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_OR"
        },
        {
            "location": "/filter/#zend92hydrator92filter92filtercompositecondition95and",
            "text": "At the given level of the composite, all filters in that condition block must\nreturn true to extract the value.",
            "title": "Zend\\Hydrator\\Filter\\FilterComposite::CONDITION_AND"
        },
        {
            "location": "/filter/#filtercomposite-examples",
            "text": "This composition will have a similar logic as the if below:  $composite = new FilterComposite();\n\n$composite->addFilter('one', $condition1);\n$composite->addFilter('two', $condition2);\n$composite->addFilter('three', $condition3);\n$composite->addFilter('four', $condition4, FilterComposite::CONDITION_AND);\n$composite->addFilter('five', $condition5, FilterComposite::CONDITION_AND);\n\n// This is what's happening internally\nif (\n     ($condition1\n        || $condition2\n        || $condition3\n     ) && ($condition4\n        && $condition5\n     )\n) {\n    //do extraction\n}  If you only have one condition (e.g., only an  and  or  or ) block, the other\none will be completely ignored.  A bit more complex filter can look like this:  $composite = new FilterComposite();\n$composite->addFilter(\n    'servicemanager',\n    new MethodMatchFilter('getServiceManager'),\n    FilterComposite::CONDITION_AND\n);\n$composite->addFilter(\n    'eventmanager',\n    new MethodMatchFilter('getEventManager'),\n    FilterComposite::CONDITION_AND\n);\n\n$hydrator->addFilter('excludes', $composite, FilterComposite::CONDITION_AND);\n\n// Internal\nif (( // default composite inside the hydrator\n        ($getFilter\n            || $hasFilter\n            || $isFilter\n        ) && (\n            $numberOfParameterFilter\n        )\n   ) && ( // new composite, added to the one above\n        $serviceManagerFilter\n        && $eventManagerFilter\n   )\n) {\n    // do extraction\n}  If you perform this on the  ClassMethods  hydrator, all getters will get\nextracted, except for  getServiceManager()  and  getEventManager() .",
            "title": "FilterComposite Examples"
        },
        {
            "location": "/filter/#using-the-provider-interface",
            "text": "FilterProviderInterface  allows you to configure the behavior of the hydrator\ninside your objects.  namespace Zend\\Hydrator\\Filter;\n\ninterface FilterProviderInterface\n{\n    /**\n     * Provides a filter for hydration\n     *\n     * @return FilterInterface\n     */\n    public function getFilter();\n}  (The  getFilter()  method is automatically excluded from  extract() .) If the\nextracted object implements the  Zend\\Hydrator\\Filter\\FilterProviderInterface ,\nthe returned  FilterInterface  instance can also be a  FilterComposite .  For example:  Class Foo implements FilterProviderInterface\n{\n     public function getFoo()\n     {\n         return 'foo';\n     }\n\n     public function hasFoo()\n     {\n         return true;\n     }\n\n     public function getServiceManager()\n     {\n         return 'servicemanager';\n     }\n\n     public function getEventManager()\n     {\n         return 'eventmanager';\n     }\n\n     public function getFilter()\n     {\n         $composite = new FilterComposite();\n         $composite->addFilter('get', new GetFilter());\n\n         $exclusionComposite = new FilterComposite();\n         $exclusionComposite->addFilter(\n             'servicemanager',\n             new MethodMatchFilter('getServiceManager'),\n             FilterComposite::CONDITION_AND\n             );\n         $exclusionComposite->addFilter(\n             'eventmanager',\n             new MethodMatchFilter('getEventManager'),\n             FilterComposite::CONDITION_AND\n         );\n\n         $composite->addFilter('excludes', $exclusionComposite, FilterComposite::CONDITION_AND);\n\n         return $composite;\n     }\n}\n\n$hydrator = new ClassMethods(false);\n$extractedArray = $hydrator->extract(new Foo());  $extractedArray  will only have 'foo' => 'foo'; all other values are\nexcluded from extraction.",
            "title": "Using the provider interface"
        },
        {
            "location": "/filter/#note",
            "text": "All pre-registered filters from the  ClassMethods  hydrator are ignored when\nthis interface is used.",
            "title": "Note"
        },
        {
            "location": "/strategy/",
            "text": "Zend\\Hydrator\\Strategy\n\n\nYou can add \nZend\\Hydrator\\Strategy\\StrategyInterface\n to any of the hydrators\n(except if it extends \nZend\\Hydrator\\AbstractHydrator\n or implements\n\nZend\\Hydrator\\HydratorInterface\n and \nZend\\Hydrator\\Strategy\\StrategyEnabledInterface\n)\nto manipulate the way how they behave on \nextract()\n and \nhydrate()\n for\nspecific key / value pairs. This is the interface that needs to be implemented:\n\n\nnamespace Zend\\Hydrator\\Strategy;\n\ninterface StrategyInterface\n{\n     /**\n      * Converts the given value so that it can be extracted by the hydrator.\n      *\n      * @param mixed $value The original value.\n      * @return mixed Returns the value that should be extracted.\n      */\n     public function extract($value);\n\n     /**\n      * Converts the given value so that it can be hydrated by the hydrator.\n      *\n      * @param mixed $value The original value.\n      * @return mixed Returns the value that should be hydrated.\n      */\n     public function hydrate($value);\n}\n\n\n\n\nThis interface is similar to \nZend\\Hydrator\\HydratorInterface\n; the reason\nis that strategies provide a proxy implementation for \nhydrate()\n and \nextract()\n.\n\n\nAdding strategies to the hydrators\n\n\nTo allow strategies within your hydrator, \nZend\\Hydrator\\Strategy\\StrategyEnabledInterface\n\nprovides the following methods:\n\n\nnamespace Zend\\Hydrator;\n\nuse Zend\\Hydrator\\Strategy\\StrategyInterface;\n\ninterface StrategyEnabledInterface\n{\n    /**\n     * Adds the given strategy under the given name.\n     *\n     * @param string $name The name of the strategy to register.\n     * @param StrategyInterface $strategy The strategy to register.\n     * @return HydratorInterface\n     */\n    public function addStrategy($name, StrategyInterface $strategy);\n\n    /**\n     * Gets the strategy with the given name.\n     *\n     * @param string $name The name of the strategy to get.\n     * @return StrategyInterface\n     */\n    public function getStrategy($name);\n\n    /**\n     * Checks if the strategy with the given name exists.\n     *\n     * @param string $name The name of the strategy to check for.\n     * @return bool\n     */\n    public function hasStrategy($name);\n\n    /**\n     * Removes the strategy with the given name.\n     *\n     * @param string $name The name of the strategy to remove.\n     * @return HydratorInterface\n     */\n    public function removeStrategy($name);\n}\n\n\n\n\nEvery hydrator shipped by default provides this functionality;\n\nAbstractHydrator\n fully implements it as well. As such, if you want to use this\nfunctionality in your own hydrators, you should extend \nAbstractHydrator\n.\n\n\nAvailable implementations\n\n\nZend\\Hydrator\\Strategy\\BooleanStrategy\n\n\nThis strategy converts values into Booleans and vice versa. It expects two\narguments at the constructor, which are used to define value maps for \ntrue\n and\n\nfalse\n.\n\n\nZend\\Hydrator\\Strategy\\ClosureStrategy\n\n\nThis is a strategy that allows you to pass in options for:\n\n\n\n\nhydrate\n, a callback to be called when hydrating a value, and\n\n\nextract\n, a callback to be called when extracting a value.\n\n\n\n\nZend\\Hydrator\\Strategy\\DateTimeFormatterStrategy\n\n\nDateTimeFormatterStrategy\n provides bidirectional conversion between strings\nand DateTime instances. The input and output formats can be provided as\nconstructor arguments.\n\n\nZend\\Hydrator\\Strategy\\DefaultStrategy\n\n\nThe \nDefaultStrategy\n simply proxies everything through, without performing any\nconversion of values.\n\n\nZend\\Hydrator\\Strategy\\ExplodeStrategy\n\n\nThis strategy is a wrapper around PHP's \nimplode()\n and \nexplode()\n functions.\nThe delemiter and a limit can be provided to the constructor; the limit will\nonly be used for \nextract\n operations.\n\n\nZend\\Hydrator\\Strategy\\SerializableStrategy\n\n\nSerializableStrategy\n provides the functionality backing\n\nZend\\Hydrator\\ArraySerializable\n. You can use it with custom implementations\nfor \nZend\\Serializer\\Adapter\\AdapterInterface\n if you want to as well.\n\n\nZend\\Hydrator\\Strategy\\StrategyChain\n\n\nThis strategy takes an array of \nStrategyInterface\n instances and iterates \nover them when performing \nextract()\n and \nhydrate()\n operations. Each operates\non the return value of the previous, allowing complex operations based on\nsmaller, single-purpose strategies.\n\n\nWriting custom strategies\n\n\nThe following example, while not terribly useful, will provide you with the\nbasics for writing your own strategies, as well as provide ideas as to where and\nwhen to use them. This strategy simply transforms the value for the defined key\nusing \nstr_rot13()\n during both the \nextract()\n and \nhydrate()\n operations:\n\n\nclass Rot13Strategy implements StrategyInterface\n{\n    public function extract($value)\n    {\n        return str_rot13($value);\n    }\n\n    public function hydrate($value)\n    {\n        return str_rot13($value);\n    }\n}\n\n\n\n\nThis is the example class with which we want to use the hydrator example:\n\n\nclass Foo\n{\n    protected $foo = null;\n    protected $bar = null;\n\n    public function getFoo()\n    {\n        return $this->foo;\n    }\n\n    public function setFoo($foo)\n    {\n        $this->foo = $foo;\n    }\n\n    public function getBar()\n    {\n        return $this->bar;\n    }\n\n    public function setBar($bar)\n    {\n        $this->bar = $bar;\n    }\n}\n\n\n\n\nNow, we'll add the \nrot13\n strategy to the method \ngetFoo()\n and \nsetFoo($foo)\n:\n\n\n$foo = new Foo();\n$foo->setFoo('bar');\n$foo->setBar('foo');\n\n$hydrator = new ClassMethods();\n$hydrator->addStrategy('foo', new Rot13Strategy());\n\n\n\n\nWhen you use the hydrator to extract an array for the object \n$foo\n, you'll\nreceive the following:\n\n\n$extractedArray = $hydrator->extract($foo);\n\n// array(2) {\n//     [\"foo\"]=>\n//     string(3) \"one\"\n//     [\"bar\"]=>\n//     string(3) \"foo\"\n// }\n\n\n\n\nAnd when hydrating a new \nFoo\n instance:\n\n\n$hydrator->hydrate($extractedArray, $foo)\n\n// object(Foo)#2 (2) {\n//   [\"foo\":protected]=>\n//   string(3) \"bar\"\n//   [\"bar\":protected]=>\n//   string(3) \"foo\"\n// }",
            "title": "Strategies"
        },
        {
            "location": "/strategy/#zend92hydrator92strategy",
            "text": "You can add  Zend\\Hydrator\\Strategy\\StrategyInterface  to any of the hydrators\n(except if it extends  Zend\\Hydrator\\AbstractHydrator  or implements Zend\\Hydrator\\HydratorInterface  and  Zend\\Hydrator\\Strategy\\StrategyEnabledInterface )\nto manipulate the way how they behave on  extract()  and  hydrate()  for\nspecific key / value pairs. This is the interface that needs to be implemented:  namespace Zend\\Hydrator\\Strategy;\n\ninterface StrategyInterface\n{\n     /**\n      * Converts the given value so that it can be extracted by the hydrator.\n      *\n      * @param mixed $value The original value.\n      * @return mixed Returns the value that should be extracted.\n      */\n     public function extract($value);\n\n     /**\n      * Converts the given value so that it can be hydrated by the hydrator.\n      *\n      * @param mixed $value The original value.\n      * @return mixed Returns the value that should be hydrated.\n      */\n     public function hydrate($value);\n}  This interface is similar to  Zend\\Hydrator\\HydratorInterface ; the reason\nis that strategies provide a proxy implementation for  hydrate()  and  extract() .",
            "title": "Zend\\Hydrator\\Strategy"
        },
        {
            "location": "/strategy/#adding-strategies-to-the-hydrators",
            "text": "To allow strategies within your hydrator,  Zend\\Hydrator\\Strategy\\StrategyEnabledInterface \nprovides the following methods:  namespace Zend\\Hydrator;\n\nuse Zend\\Hydrator\\Strategy\\StrategyInterface;\n\ninterface StrategyEnabledInterface\n{\n    /**\n     * Adds the given strategy under the given name.\n     *\n     * @param string $name The name of the strategy to register.\n     * @param StrategyInterface $strategy The strategy to register.\n     * @return HydratorInterface\n     */\n    public function addStrategy($name, StrategyInterface $strategy);\n\n    /**\n     * Gets the strategy with the given name.\n     *\n     * @param string $name The name of the strategy to get.\n     * @return StrategyInterface\n     */\n    public function getStrategy($name);\n\n    /**\n     * Checks if the strategy with the given name exists.\n     *\n     * @param string $name The name of the strategy to check for.\n     * @return bool\n     */\n    public function hasStrategy($name);\n\n    /**\n     * Removes the strategy with the given name.\n     *\n     * @param string $name The name of the strategy to remove.\n     * @return HydratorInterface\n     */\n    public function removeStrategy($name);\n}  Every hydrator shipped by default provides this functionality; AbstractHydrator  fully implements it as well. As such, if you want to use this\nfunctionality in your own hydrators, you should extend  AbstractHydrator .",
            "title": "Adding strategies to the hydrators"
        },
        {
            "location": "/strategy/#available-implementations",
            "text": "",
            "title": "Available implementations"
        },
        {
            "location": "/strategy/#zend92hydrator92strategy92booleanstrategy",
            "text": "This strategy converts values into Booleans and vice versa. It expects two\narguments at the constructor, which are used to define value maps for  true  and false .",
            "title": "Zend\\Hydrator\\Strategy\\BooleanStrategy"
        },
        {
            "location": "/strategy/#zend92hydrator92strategy92closurestrategy",
            "text": "This is a strategy that allows you to pass in options for:   hydrate , a callback to be called when hydrating a value, and  extract , a callback to be called when extracting a value.",
            "title": "Zend\\Hydrator\\Strategy\\ClosureStrategy"
        },
        {
            "location": "/strategy/#zend92hydrator92strategy92datetimeformatterstrategy",
            "text": "DateTimeFormatterStrategy  provides bidirectional conversion between strings\nand DateTime instances. The input and output formats can be provided as\nconstructor arguments.",
            "title": "Zend\\Hydrator\\Strategy\\DateTimeFormatterStrategy"
        },
        {
            "location": "/strategy/#zend92hydrator92strategy92defaultstrategy",
            "text": "The  DefaultStrategy  simply proxies everything through, without performing any\nconversion of values.",
            "title": "Zend\\Hydrator\\Strategy\\DefaultStrategy"
        },
        {
            "location": "/strategy/#zend92hydrator92strategy92explodestrategy",
            "text": "This strategy is a wrapper around PHP's  implode()  and  explode()  functions.\nThe delemiter and a limit can be provided to the constructor; the limit will\nonly be used for  extract  operations.",
            "title": "Zend\\Hydrator\\Strategy\\ExplodeStrategy"
        },
        {
            "location": "/strategy/#zend92hydrator92strategy92serializablestrategy",
            "text": "SerializableStrategy  provides the functionality backing Zend\\Hydrator\\ArraySerializable . You can use it with custom implementations\nfor  Zend\\Serializer\\Adapter\\AdapterInterface  if you want to as well.",
            "title": "Zend\\Hydrator\\Strategy\\SerializableStrategy"
        },
        {
            "location": "/strategy/#zend92hydrator92strategy92strategychain",
            "text": "This strategy takes an array of  StrategyInterface  instances and iterates \nover them when performing  extract()  and  hydrate()  operations. Each operates\non the return value of the previous, allowing complex operations based on\nsmaller, single-purpose strategies.",
            "title": "Zend\\Hydrator\\Strategy\\StrategyChain"
        },
        {
            "location": "/strategy/#writing-custom-strategies",
            "text": "The following example, while not terribly useful, will provide you with the\nbasics for writing your own strategies, as well as provide ideas as to where and\nwhen to use them. This strategy simply transforms the value for the defined key\nusing  str_rot13()  during both the  extract()  and  hydrate()  operations:  class Rot13Strategy implements StrategyInterface\n{\n    public function extract($value)\n    {\n        return str_rot13($value);\n    }\n\n    public function hydrate($value)\n    {\n        return str_rot13($value);\n    }\n}  This is the example class with which we want to use the hydrator example:  class Foo\n{\n    protected $foo = null;\n    protected $bar = null;\n\n    public function getFoo()\n    {\n        return $this->foo;\n    }\n\n    public function setFoo($foo)\n    {\n        $this->foo = $foo;\n    }\n\n    public function getBar()\n    {\n        return $this->bar;\n    }\n\n    public function setBar($bar)\n    {\n        $this->bar = $bar;\n    }\n}  Now, we'll add the  rot13  strategy to the method  getFoo()  and  setFoo($foo) :  $foo = new Foo();\n$foo->setFoo('bar');\n$foo->setBar('foo');\n\n$hydrator = new ClassMethods();\n$hydrator->addStrategy('foo', new Rot13Strategy());  When you use the hydrator to extract an array for the object  $foo , you'll\nreceive the following:  $extractedArray = $hydrator->extract($foo);\n\n// array(2) {\n//     [\"foo\"]=>\n//     string(3) \"one\"\n//     [\"bar\"]=>\n//     string(3) \"foo\"\n// }  And when hydrating a new  Foo  instance:  $hydrator->hydrate($extractedArray, $foo)\n\n// object(Foo)#2 (2) {\n//   [\"foo\":protected]=>\n//   string(3) \"bar\"\n//   [\"bar\":protected]=>\n//   string(3) \"foo\"\n// }",
            "title": "Writing custom strategies"
        },
        {
            "location": "/aggregate/",
            "text": "AggregateHydrator\n\n\nZend\\Hydrator\\Aggregate\\AggregateHydrator\n is an implementation of\n\nZend\\Hydrator\\HydratorInterface\n that composes multiple hydrators via event listeners.\n\n\nYou typically want to use an aggregate hydrator when you want to hydrate or extract data from\ncomplex objects that implement multiple interfaces, and therefore need multiple hydrators to handle\nthat in subsequent steps.\n\n\nInstallation requirements\n\n\nThe \nAggregateHydrator\n depends on the zend-eventmanager component, so be sure to have it\ninstalled before getting started:\n\n\n$ composer require zendframework/zend-eventmanager\n\n\n\n\nBasic usage\n\n\nA simple use case may be hydrating a \nBlogPost\n object, which contains data for the user that\ncreated it, the time it was created, the current publishing status, etc:\n\n\nuse Zend\\Hydrator\\Aggregate\\AggregateHydrator;\n\n$hydrator = new AggregateHydrator();\n\n// attach the various hydrators capable of handling simpler interfaces\n$hydrator->add(new My\\BlogPostHydrator());\n$hydrator->add(new My\\UserAwareObjectHydrator());\n$hydrator->add(new My\\TimestampedObjectHydrator());\n$hydrator->add(new My\\PublishableObjectHydrator());\n// ...\n\n// Now retrieve the BlogPost object\n// ...\n\n// you can now extract complex data from a blogpost\n$data = $hydrator->extract($blogPost);\n\n// or you can fill the object with complex data\n$blogPost = $hydrator->hydrate($data, $blogPost);\n\n\n\n\n\n\nHydrator priorities\n\n\nAggregateHydrator::add\n has a second optional argument, \n$priority\n. If you\nhave two or more hydrators that conflict with each other for same data keys,\nyou may decide which one to execute first or last by passing a higher or lower\ninteger priority, respectively, to this argument.\n\n\n\n\nIn order to work with this logic, each of the hydrators that are attached should\nignore any unknown object type passed in:\n\n\nnamespace My;\n\nuse Zend\\Hydrator\\HydratorInterface\n\nclass BlogPostHydrator implements HydratorInterface\n{\n    public function hydrate($data, $object)\n    {\n        if (! $object instanceof BlogPost) {\n            return $object;\n        }\n\n        // ... continue hydration ...\n    }\n\n    public function extract($object)\n    {\n        if (! $object instanceof BlogPost) {\n            return array();\n        }\n\n        // ... continue extraction ...\n    }\n}\n\n\n\n\nAdvanced use cases\n\n\nSince the \nAggregateHydrator\n is event-driven, you can use the \nEventManager\n\nAPI to tweak its behaviour.\n\n\nCommon use cases include:\n\n\n\n\nRemoval of hydrated data keys (passwords/confidential information) depending\n  on business rules.\n\n\nCaching of the hydration/extraction process.\n\n\nTransformations on extracted data, for compatibility with third-party APIs.\n\n\n\n\nIn the following example, a cache listener is introduced to speed up hydration, which can be\nvery useful when the same data is requested multiple times:\n\n\nuse Zend\\Hydrator\\Aggregate\\AggregateHydrator;\nuse Zend\\Hydrator\\Aggregate\\ExtractEvent;\nuse Zend\\Cache\\Storage\\Adapter\\Memory;\n\n$hydrator = new AggregateHydrator();\n\n// Attach the various hydrators:\n$hydrator->add(new My\\BlogPostHydrator());\n$hydrator->add(new My\\UserAwareObjectHydrator());\n$hydrator->add(new My\\TimestampedObjectHydrator());\n$hydrator->add(new My\\PublishableObjectHydrator());\n// ...\n\n$cache             = new Memory();\n$cacheReadListener = function (ExtractEvent $event) use ($cache) {\n    $object = $event->getExtractionObject();\n\n    if (! $object instanceof BlogPost) {\n        return;\n    }\n\n    if ($cache->hasItem($object->getId())) {\n        $event->setExtractedData($cache->getItem($object->getId()));\n        $event->stopPropagation();\n    }\n};\n\n$cacheWriteListener = function (ExtractEvent $event) use ($cache) {\n    $object = $event->getExtractionObject();\n\n    if (! $object instanceof BlogPost) {\n        return;\n    }\n\n    $cache->setItem($object->getId(), $event->getExtractedData());\n};\n\n// Attaching a high priority listener executed before extraction logic:\n$eventManager = $hydrator->getEventManager();\n$eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000);\n\n// Attaching a low priority listener executed after extraction logic:\n$eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000);\n\n\n\n\nWith an aggregate hydrator configured in this way, any\n\n$hydrator->extract($blogPost)\n operation will be cached.",
            "title": "Aggregates"
        },
        {
            "location": "/aggregate/#aggregatehydrator",
            "text": "Zend\\Hydrator\\Aggregate\\AggregateHydrator  is an implementation of Zend\\Hydrator\\HydratorInterface  that composes multiple hydrators via event listeners.  You typically want to use an aggregate hydrator when you want to hydrate or extract data from\ncomplex objects that implement multiple interfaces, and therefore need multiple hydrators to handle\nthat in subsequent steps.",
            "title": "AggregateHydrator"
        },
        {
            "location": "/aggregate/#installation-requirements",
            "text": "The  AggregateHydrator  depends on the zend-eventmanager component, so be sure to have it\ninstalled before getting started:  $ composer require zendframework/zend-eventmanager",
            "title": "Installation requirements"
        },
        {
            "location": "/aggregate/#basic-usage",
            "text": "A simple use case may be hydrating a  BlogPost  object, which contains data for the user that\ncreated it, the time it was created, the current publishing status, etc:  use Zend\\Hydrator\\Aggregate\\AggregateHydrator;\n\n$hydrator = new AggregateHydrator();\n\n// attach the various hydrators capable of handling simpler interfaces\n$hydrator->add(new My\\BlogPostHydrator());\n$hydrator->add(new My\\UserAwareObjectHydrator());\n$hydrator->add(new My\\TimestampedObjectHydrator());\n$hydrator->add(new My\\PublishableObjectHydrator());\n// ...\n\n// Now retrieve the BlogPost object\n// ...\n\n// you can now extract complex data from a blogpost\n$data = $hydrator->extract($blogPost);\n\n// or you can fill the object with complex data\n$blogPost = $hydrator->hydrate($data, $blogPost);",
            "title": "Basic usage"
        },
        {
            "location": "/aggregate/#hydrator-priorities",
            "text": "AggregateHydrator::add  has a second optional argument,  $priority . If you\nhave two or more hydrators that conflict with each other for same data keys,\nyou may decide which one to execute first or last by passing a higher or lower\ninteger priority, respectively, to this argument.   In order to work with this logic, each of the hydrators that are attached should\nignore any unknown object type passed in:  namespace My;\n\nuse Zend\\Hydrator\\HydratorInterface\n\nclass BlogPostHydrator implements HydratorInterface\n{\n    public function hydrate($data, $object)\n    {\n        if (! $object instanceof BlogPost) {\n            return $object;\n        }\n\n        // ... continue hydration ...\n    }\n\n    public function extract($object)\n    {\n        if (! $object instanceof BlogPost) {\n            return array();\n        }\n\n        // ... continue extraction ...\n    }\n}",
            "title": "Hydrator priorities"
        },
        {
            "location": "/aggregate/#advanced-use-cases",
            "text": "Since the  AggregateHydrator  is event-driven, you can use the  EventManager \nAPI to tweak its behaviour.  Common use cases include:   Removal of hydrated data keys (passwords/confidential information) depending\n  on business rules.  Caching of the hydration/extraction process.  Transformations on extracted data, for compatibility with third-party APIs.   In the following example, a cache listener is introduced to speed up hydration, which can be\nvery useful when the same data is requested multiple times:  use Zend\\Hydrator\\Aggregate\\AggregateHydrator;\nuse Zend\\Hydrator\\Aggregate\\ExtractEvent;\nuse Zend\\Cache\\Storage\\Adapter\\Memory;\n\n$hydrator = new AggregateHydrator();\n\n// Attach the various hydrators:\n$hydrator->add(new My\\BlogPostHydrator());\n$hydrator->add(new My\\UserAwareObjectHydrator());\n$hydrator->add(new My\\TimestampedObjectHydrator());\n$hydrator->add(new My\\PublishableObjectHydrator());\n// ...\n\n$cache             = new Memory();\n$cacheReadListener = function (ExtractEvent $event) use ($cache) {\n    $object = $event->getExtractionObject();\n\n    if (! $object instanceof BlogPost) {\n        return;\n    }\n\n    if ($cache->hasItem($object->getId())) {\n        $event->setExtractedData($cache->getItem($object->getId()));\n        $event->stopPropagation();\n    }\n};\n\n$cacheWriteListener = function (ExtractEvent $event) use ($cache) {\n    $object = $event->getExtractionObject();\n\n    if (! $object instanceof BlogPost) {\n        return;\n    }\n\n    $cache->setItem($object->getId(), $event->getExtractedData());\n};\n\n// Attaching a high priority listener executed before extraction logic:\n$eventManager = $hydrator->getEventManager();\n$eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheReadListener, 1000);\n\n// Attaching a low priority listener executed after extraction logic:\n$eventManager()->attach(ExtractEvent::EVENT_EXTRACT, $cacheWriteListener, -1000);  With an aggregate hydrator configured in this way, any $hydrator->extract($blogPost)  operation will be cached.",
            "title": "Advanced use cases"
        },
        {
            "location": "/naming-strategy/identity-naming-strategy/",
            "text": "IdentityNamingStrategy\n\n\nZend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy\n uses the keys provided to\nit for hydration and extraction.\n\n\nBasic Usage\n\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy();\n\necho $namingStrategy->hydrate('foo'); // outputs: foo\necho $namingStrategy->extract('bar'); // outputs: bar\n\n\n\n\nThis strategy can be used in hydrators as well:\n\n\nclass Foo\n{\n    public $foo;\n}\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy();\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$hydrator->hydrate(array('foo' => 123), $foo);\n\nprint_r($foo); // Foo Object ( [foo] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 )",
            "title": "Identity"
        },
        {
            "location": "/naming-strategy/identity-naming-strategy/#identitynamingstrategy",
            "text": "Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy  uses the keys provided to\nit for hydration and extraction.",
            "title": "IdentityNamingStrategy"
        },
        {
            "location": "/naming-strategy/identity-naming-strategy/#basic-usage",
            "text": "$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy();\n\necho $namingStrategy->hydrate('foo'); // outputs: foo\necho $namingStrategy->extract('bar'); // outputs: bar  This strategy can be used in hydrators as well:  class Foo\n{\n    public $foo;\n}\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\IdentityNamingStrategy();\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$hydrator->hydrate(array('foo' => 123), $foo);\n\nprint_r($foo); // Foo Object ( [foo] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 )",
            "title": "Basic Usage"
        },
        {
            "location": "/naming-strategy/map-naming-strategy/",
            "text": "MapNamingStrategy\n\n\nZend\\Hydrator\\NamingStrategy\\MapNamingStrategy\n allows you to provide a map of\nkeys to use when hydrating and extracting; the map will translate the key based\non the direction.\n\n\nBasic Usage\n\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy(array(\n    'foo' => 'bar',\n    'baz' => 'bash'\n));\necho $namingStrategy->hydrate('foo'); // outputs: bar\necho $namingStrategy->hydrate('baz'); // outputs: bash\n\necho $namingStrategy->extract('bar'); // outputs: foo\necho $namingStrategy->extract('bash'); // outputs: baz\n\n\n\n\nThis strategy can be used in hydrators to dictate how keys should be mapped:\n\n\nclass Foo\n{\n    public $bar;\n}\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar',\n    'baz' => 'bash'\n]);\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$hydrator->hydrate(['foo' => 123], $foo);\n\nprint_r($foo); // Foo Object ( [bar] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 )",
            "title": "Mapping"
        },
        {
            "location": "/naming-strategy/map-naming-strategy/#mapnamingstrategy",
            "text": "Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy  allows you to provide a map of\nkeys to use when hydrating and extracting; the map will translate the key based\non the direction.",
            "title": "MapNamingStrategy"
        },
        {
            "location": "/naming-strategy/map-naming-strategy/#basic-usage",
            "text": "$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy(array(\n    'foo' => 'bar',\n    'baz' => 'bash'\n));\necho $namingStrategy->hydrate('foo'); // outputs: bar\necho $namingStrategy->hydrate('baz'); // outputs: bash\n\necho $namingStrategy->extract('bar'); // outputs: foo\necho $namingStrategy->extract('bash'); // outputs: baz  This strategy can be used in hydrators to dictate how keys should be mapped:  class Foo\n{\n    public $bar;\n}\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar',\n    'baz' => 'bash'\n]);\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$hydrator->hydrate(['foo' => 123], $foo);\n\nprint_r($foo); // Foo Object ( [bar] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 )",
            "title": "Basic Usage"
        },
        {
            "location": "/naming-strategy/underscore-naming-strategy/",
            "text": "UnderscoreNamingStrategy\n\n\nZend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy\n converts snake case strings (e.g.\n\nfoo_bar_baz\n) to camel-case strings (e.g. \nfooBarBaz\n) and vice versa.\n\n\nBasic Usage\n\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\necho $namingStrategy->extract('foo_bar'); // outputs: foo_bar\necho $namingStrategy->extract('Foo_Bar'); // outputs: foo_bar\necho $namingStrategy->extract('FooBar'); // outputs: foo_bar\n\necho $namingStrategy->hydrate('fooBar'); // outputs: fooBar\necho $namingStrategy->hydrate('FooBar'); // outputs: fooBar\necho $namingStrategy->hydrate('Foo_Bar'); // outputs: fooBar\n\n\n\n\nThis strategy can be used in hydrators to dictate how keys should be mapped.\n\n\nclass Foo\n{\n    public $fooBar;\n}\n\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy(new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy());\n\n$foo = new Foo();\n$hydrator->hydrate(['foo_bar' => 123], $foo);\n\nprint_r($foo); // Foo Object ( [fooBar] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo_bar] => 123 )",
            "title": "Underscore Mapping"
        },
        {
            "location": "/naming-strategy/underscore-naming-strategy/#underscorenamingstrategy",
            "text": "Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy  converts snake case strings (e.g. foo_bar_baz ) to camel-case strings (e.g.  fooBarBaz ) and vice versa.",
            "title": "UnderscoreNamingStrategy"
        },
        {
            "location": "/naming-strategy/underscore-naming-strategy/#basic-usage",
            "text": "$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\necho $namingStrategy->extract('foo_bar'); // outputs: foo_bar\necho $namingStrategy->extract('Foo_Bar'); // outputs: foo_bar\necho $namingStrategy->extract('FooBar'); // outputs: foo_bar\n\necho $namingStrategy->hydrate('fooBar'); // outputs: fooBar\necho $namingStrategy->hydrate('FooBar'); // outputs: fooBar\necho $namingStrategy->hydrate('Foo_Bar'); // outputs: fooBar  This strategy can be used in hydrators to dictate how keys should be mapped.  class Foo\n{\n    public $fooBar;\n}\n\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy(new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy());\n\n$foo = new Foo();\n$hydrator->hydrate(['foo_bar' => 123], $foo);\n\nprint_r($foo); // Foo Object ( [fooBar] => 123 )\nprint_r($hydrator->extract($foo)); // Array ( [foo_bar] => 123 )",
            "title": "Basic Usage"
        },
        {
            "location": "/naming-strategy/composite-naming-strategy/",
            "text": "CompositeNamingStrategy\n\n\nZend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy\n allows you to specify which naming\nstrategy should be used for each key encountered during hydration or extraction.\n\n\nBasic Usage\n\n\nWhen invoked, the following composite strategy will extract the property \nbar\n\nto the array key \nfoo\n (using the \nMapNamingStrategy\n), and the property\n\nbarBat\n to the array key \nbar_bat\n (using the \nUnderscoreNamingStrategy\n):\n\n\nclass Foo\n{\n    public $bar;\n    public $barBat;\n}\n\n$mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar'\n]);\n\n$underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([\n    'bar' => $mapStrategy,\n    'barBat' => $underscoreNamingStrategy,\n]);\n\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$foo->bar = 123;\n$foo->barBat = 42;\n\nprint_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 [bar_bat] => 42 ) \n\n\n\n\nUnfortunately, the \nCompositeNamingStrategy\n can only be used for extraction as it will not know how\nto handle the keys necessary for hydration (\nfoo\n and \nbar_bat\n, respectively). To rectify this we\nhave to cover the keys for both hydration and extraction in our composite strategy:\n\n\nclass Foo\n{\n    public $bar;\n    public $barBat;\n}\n\n$mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar'\n]);\n\n$underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([\n    // Define both directions for the foo => bar mapping\n    'bar' => $mapStrategy,\n    'foo' => $mapStrategy,\n    // Define both directions for the barBat => bar_bat mapping\n    'barBat' => $underscoreNamingStrategy,\n    'bar_bat' => $underscoreNamingStrategy,\n]);\n\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$foo->bar = 123;\n$foo->barBat = 42;\n\n$array = $hydrator->extract($foo);\n\nprint_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 )\nprint_r($array); // Array ( [foo] => 123 [bar_bat] => 42 ) \n\n$foo2 = new Foo();\n$hydrator->hydrate($array, $foo2);\n\nprint_r($foo2); // Foo Object ( [bar] => 123 [barBat] => 42 )",
            "title": "Composite"
        },
        {
            "location": "/naming-strategy/composite-naming-strategy/#compositenamingstrategy",
            "text": "Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy  allows you to specify which naming\nstrategy should be used for each key encountered during hydration or extraction.",
            "title": "CompositeNamingStrategy"
        },
        {
            "location": "/naming-strategy/composite-naming-strategy/#basic-usage",
            "text": "When invoked, the following composite strategy will extract the property  bar \nto the array key  foo  (using the  MapNamingStrategy ), and the property barBat  to the array key  bar_bat  (using the  UnderscoreNamingStrategy ):  class Foo\n{\n    public $bar;\n    public $barBat;\n}\n\n$mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar'\n]);\n\n$underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([\n    'bar' => $mapStrategy,\n    'barBat' => $underscoreNamingStrategy,\n]);\n\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$foo->bar = 123;\n$foo->barBat = 42;\n\nprint_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 )\nprint_r($hydrator->extract($foo)); // Array ( [foo] => 123 [bar_bat] => 42 )   Unfortunately, the  CompositeNamingStrategy  can only be used for extraction as it will not know how\nto handle the keys necessary for hydration ( foo  and  bar_bat , respectively). To rectify this we\nhave to cover the keys for both hydration and extraction in our composite strategy:  class Foo\n{\n    public $bar;\n    public $barBat;\n}\n\n$mapStrategy = new Zend\\Hydrator\\NamingStrategy\\MapNamingStrategy([\n    'foo' => 'bar'\n]);\n\n$underscoreNamingStrategy = new Zend\\Hydrator\\NamingStrategy\\UnderscoreNamingStrategy();\n\n$namingStrategy = new Zend\\Hydrator\\NamingStrategy\\CompositeNamingStrategy([\n    // Define both directions for the foo => bar mapping\n    'bar' => $mapStrategy,\n    'foo' => $mapStrategy,\n    // Define both directions for the barBat => bar_bat mapping\n    'barBat' => $underscoreNamingStrategy,\n    'bar_bat' => $underscoreNamingStrategy,\n]);\n\n$hydrator = new Zend\\Hydrator\\ObjectProperty();\n$hydrator->setNamingStrategy($namingStrategy);\n\n$foo = new Foo();\n$foo->bar = 123;\n$foo->barBat = 42;\n\n$array = $hydrator->extract($foo);\n\nprint_r($foo); // Foo Object ( [bar] => 123 [barBat] => 42 )\nprint_r($array); // Array ( [foo] => 123 [bar_bat] => 42 ) \n\n$foo2 = new Foo();\n$hydrator->hydrate($array, $foo2);\n\nprint_r($foo2); // Foo Object ( [bar] => 123 [barBat] => 42 )",
            "title": "Basic Usage"
        }
    ]
}